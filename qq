import asyncio
import json
import requests
import websockets
import pickle
import pandas as pd
import logging
import telegram

# === Конфигурация ===
BYBIT_WS_URL = "wss://stream.bybit.com/v5/public/linear"
API_KEY = "your_api_key"
API_SECRET = "your_api_secret"
TELEGRAM_TOKEN = "your_telegram_token"
TELEGRAM_CHAT_ID = "your_chat_id"
ML_MODEL_PATH = "models/catboost_model.pkl"

STOP_LOSS_ATR_MULTIPLIER = 2
TAKE_PROFIT_ATR_MULTIPLIER = 3

# === Логирование ===
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("CryptoBot")

# === Telegram Bot ===
class TelegramBot:
    def __init__(self):
        self.bot = telegram.Bot(token=TELEGRAM_TOKEN)

    async def send_message(self, text):
        await self.bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=text)
        logger.info(f"Отправлено в Telegram: {text}")

telegram_bot = TelegramBot()

# === Машинное обучение ===
class MLEngine:
    def __init__(self):
        with open(ML_MODEL_PATH, "rb") as f:
            self.model = pickle.load(f)

    def predict(self, df):
        features = df[["rsi", "macd"]].values
        prediction = self.model.predict(features)
        return prediction

ml_engine = MLEngine()

# === Сбор данных ===
class DataCollector:
    def __init__(self):
        self.ws_url = BYBIT_WS_URL
        self.data = []

    async def fetch_data(self):
        async with websockets.connect(self.ws_url) as ws:
            await ws.send(json.dumps({"op": "subscribe", "args": ["trade.BTCUSDT", "orderBookL2_25.BTCUSDT"]}))
            logger.info("Подключено к WebSocket Bybit")

            async for message in ws:
                data = json.loads(message)
                self.data.append(data)

    async def run(self):
        while True:
            try:
                await self.fetch_data()
            except Exception as e:
                logger.error(f"Ошибка сбора данных: {e}")
                await asyncio.sleep(5)

data_collector = DataCollector()

# === Обработка сигналов ===
class SignalProcessor:
    def generate_signals(self, market_data):
        df = pd.DataFrame(market_data)
        df["rsi"] = df["close"].rolling(14).mean()  # Простая имитация RSI
        df["macd"] = df["close"].rolling(26).mean() - df["close"].rolling(12).mean()
        
        signal = ml_engine.predict(df)
        return signal

    async def run(self):
        while True:
            market_data = data_collector.data[-100:] if len(data_collector.data) > 100 else []
            if market_data:
                signal = self.generate_signals(market_data)
                logger.info(f"Сигнал: {signal}")
                await telegram_bot.send_message(f"Сигнал: {signal}")
            await asyncio.sleep(1)

signal_processor = SignalProcessor()

# === Управление рисками ===
class RiskManager:
    def calculate_sl_tp(self, atr_value, entry_price):
        stop_loss = entry_price - (atr_value * STOP_LOSS_ATR_MULTIPLIER)
        take_profit = entry_price + (atr_value * TAKE_PROFIT_ATR_MULTIPLIER)
        return stop_loss, take_profit

risk_manager = RiskManager()

# === Исполнение ордеров ===
class OrderExecutor:
    def place_order(self, signal, amount, price):
        order = {
            "symbol": "BTCUSDT",
            "side": signal,
            "qty": amount,
            "price": price
        }
        response = requests.post("https://api.bybit.com/v2/private/order/create", headers={
            "X-BYBIT-API-KEY": API_KEY
        }, json=order)
        logger.info(f"Ордер отправлен: {response.json()}")

order_executor = OrderExecutor()

# === Запуск бота ===
async def main():
    logger.info("Запуск торгового бота...")
    await asyncio.gather(
        data_collector.run(),
        signal_processor.run()
    )

if __name__ == "__main__":
    asyncio.run(main())
